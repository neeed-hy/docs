# JS 基础--模块化

## CommonJS

### CommonJS 概述

**Node.js**中主要使用的模块化手段。每个文件就是一个模块，有自己的作用域，一个文件里定义的变量、函数、类都是私有的，对其他文件不可见。

**在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。**

CommonJS 用同步的方式加载模块。Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。

但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。

特点：

- 所有代码都晕行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了。以后再加载，就直接读取缓存结果。要让模块再次运行，就必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。

### CommonJS 基本语法

- **暴露模块**：`module.exports = value` 或 `exports.xxx = value`
- **引入模块**：`require(xxx)`,如果是第三方模块，xxx 为模块名；如果是自定义模块，xxx 为模块文件路径

```js
// 注册模块。设文件为example.js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;
//  上面代码通过module.exports输出变量x和函数addX。

// 引用与使用模块
var example = require("./example.js"); //如果参数字符串以“./”开头，则表示加载的是一个位于相对路径
console.log(example.x); // 5
console.log(example.addX(1)); // 6
```

**require 命令**用于加载模块文件。require 命令的基本功能是：**读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错**。

### CommonJS 模块加载机制

**CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。**这点与 ES6 模块化有重大差异（下文会介绍），请看下面这个例子：

```js
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};

// main.js
var counter = require("./lib").counter;
var incCounter = require("./lib").incCounter;

console.log(counter); // 3
incCounter();
console.log(counter); // 3
```

上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。**这是因为 counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值**。

## AMD 与 require.js

CommonJs 规范加载模块是同步的。也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。

正如上文所说，浏览器环境下必须使用异步加载方式。因此浏览器端一般不采用 CommonJs 规范而使用 AMD 等异步规范。

AMD 不是 JavaScript 原生支持，需要第三方库函数配合使用。需要的库是 require.js。以下的语法也是基于 require.js 的。

requireJS 主要解决两个问题

1. 多个 js 文件可能有依赖关系，**被依赖的文件需要早于依赖它的文件加载到浏览器**.
2. js 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

### AMD 规范 基本语法

- **`define()`函数**：用来定义模块的函数。
  - args0: 需引入模块的名字数组
  - arg1：依赖引入之后的 callback，callback 的参数就是引入的东西。如果有多个依赖，则参数按照引入的顺序依次传入。
- **`require()`函数**： 用来引入模块的函数。

```js
define(["dependence_name"], (args) => {
  // args就是从dependence_name引入的东西
  // ...  code ...
  return your_export;
});

require(["import_module_name"], (args) => {
  // args就是从import_module_name引入的东西
  // ...  code ...
});
```

样例代码可以在[这里](https://juejin.im/post/5c17ad756fb9a049ff4e0a62)进行查阅。

## CMD 与 Sea.js

CMD 规范专门用于浏览器端。和 AMD 一样，模块的加载是**异步**的，在使用时才会加载执行。在 CMD 规范中，**一个模块就是一个文件**。

和 CMD 配合使用的第三方库是 Sea.js。

### CMD 规范 基本语法

```js
define(function (require, exprots, module) {
  const fs = require("fs"); //接受模块标识作为唯一参数
  // exports，module则和CommonJS类似
  exports.module = {
    props: "value",
  };
});

seajs.use(["test.js"], function (test_exports) {
  // ....
});
```

样例代码可以在[这里](https://juejin.im/post/5c17ad756fb9a049ff4e0a62)进行查阅。

## AMD 和 CMD 的区别

**最明显的区别**就是在模块定义时对依赖的处理不同。

- AMD 推崇**依赖前置**，在定义模块的时候就要声明其依赖的模块
- CMD 推崇**就近依赖**，只有在用到某个模块的时候再去 require

AMD 和 CMD**最大的区别**是对依赖模块的**执行时机处理**不同,注意不是加载的时机或者方式不同。

同样都是异步加载模块，AMD 在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入 require 的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。

CMD 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。

表格的形式：

|                        | AMD                                                                                                                                                                                                                                 | CMD                                                                                                                                                                     |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 加载方式               | 异步加载                                                                                                                                                                                                                            | 异步加载                                                                                                                                                                |
| 定义模块时对依赖的处理 | 推崇依赖前置，在定义的时候就要声明其依赖的模块                                                                                                                                                                                      | 推崇就近依赖，只有用到模块的时候采取 require                                                                                                                            |
| 执行模块的方式         | 加载 module 完成后就会执行该 module，所有 module 都加载执行完成后会进入 require 的回调函数，执行主逻辑。依赖的执行顺序和书写的顺序不一定一致，谁先下载完谁先执行，但是主逻辑 一定在所有的依赖加载完成后才执行(有点类似 Promise.all) | 加载完某个依赖后并不执行，只是下载而已。在所有的 module 加载完成后进入主逻辑，遇到 require 语句的时候才会执行对应的 module。module 的执行顺序和书写的顺序是完全一致的。 |

## ES6 模块化

ES6 在**语言标准**的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：**export 和 import**。**export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能**。

ES6 模块区别于 CommonJS 的运行时加载，import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行(类似于函数声明优先于其他语句那样)， 也就是说在文件的任何位置 import 引入模块都会被提前到文件顶部。

ES6 的模块 自动开启严格模式，即使没有写'use strict'; 。 运行一个包含 import 声明的模块时，被引入的模块先导入并加载，然后根据依赖关系，每个模块的内容会使用深度优先的原则进行遍历。跳过已经执行过的模块，避免依赖循环。

### ES6 模块化语法

`export` 命令用于规定模块的对外接口，`import` 命令用于输入其他模块提供的功能。

使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。可以使用 export default 命令，为模块指定默认输出，这样 import 时就可以直接引用。

```js
import { prop } from "app"; //从app中导入prop
import { prop as newProp } from "app"; // 功能和上面一样，不过是将导入的prop重命名为newProp

import App from "App"; // 导入App的default
import * as App from "App"; // 导入App的所有属性到App对象中

export const variable = "value"; // 导出一个名为variable的常量
export { variable as newVar }; // 和import 的重命名类似，将variable作为newVar导出

export default variable = "value"; // 将variable作为默认导出
export { variable as default }; //  和上面的写法基本一样
```

## ES6 与 CommonJS 的差异

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

  - 举一个 CommonJS 部分中出现过的例子：

  ```js
  // lib.js
  export let counter = 3;
  export function incCounter() {
    counter++;
  }
  // main.js
  import { counter, incCounter } from "./lib";
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
  ```

  - **ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块**。

- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

  - 因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。
  - 而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

## 总结

- CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD CMD 解决方案。
- AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
- CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重
- ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

## 参考出处

1. [2dunn-import、require、export、module.exports 混合使用详解](https://juejin.im/post/5a2e5f0851882575d42f5609)
2. [subwaydown-前端模块化：CommonJS,AMD,CMD,ES6](https://juejin.im/post/5aaa37c8f265da23945f365c)
3. [浪里行舟-前端模块化详解(完整版)](https://juejin.im/post/5c17ad756fb9a049ff4e0a62)
4. [singer-coder 前端模块化，AMD 与 CMD 的区别](https://juejin.im/post/5a422b036fb9a045211ef789)
5. [wbcs-web 系列之模块化——AMD、CMD、CommonJS、ES6 整理&&比较](https://juejin.im/post/5bd0773051882576c51de038)
