---
sidebar_position: 6
description: '使用 SplitChunksPlugin 来对 Webpack 打包的产物进行优化'
---

# 产物优化-分包

## 理解 Chunk

Chunk 是 webpack 的一个重要概念，用来组织、管理、优化最终产物。

在 Webpack 的构建流程中：

- Webpack 首先根据 `entry` 配置创建若干 Chunk 对象；
- 在遍历、构建阶段，Webpack 会找到所有的 Module 对象，同一 Entry 下的模块会分配到该 Entry 对应的 Chunk 中；
- 异步模块会创建新的 Chunk 对象，并将异步模块放入该 Chunk；
- (如果配置了 `SplitChunksPlugin`) Module 分配完毕后，会利用 `SplitChunksPlugin` 进一步的优化这些 Chunk；
- 最后将 Chunk 输出成最终的产物（Asset）文件，编译工作到此结束。

![chunk示意图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73dad47e4d3e45419a9ad3f7ff746fa0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以看到，Chunk 在构建流程中非常关键：

- 一方面作为 Module 容器，根据一系列**默认分包策略**决定那些模块应该合并在一起打包；
- 另一方面根据 `SplitChunksPlugin` 的配置进行**分包优化**，决定最终输出的产物文件。

Webpack 的默认分包规则有：

- Initial Chunk：`entry` 模块及相应子模块打包成 Initial Chunk；
- Async Chunk：通过 `import(./xxx)` 等语句导入的异步模块和它相应的子模块组成 Async Chunk;
- Runtime Chunk：运行时代码抽离成 Runtime Chunk，可以通过 `entry.runtime` 进行配置。

先忽略 Runtime Chunk。Initial Chunk 和 Async Chunk 的这种简单的打包规则会产生一些问题：

- **模块重复打包**。如果两个入口同时依赖同一个文件，那么这个文件就会被同时打入到这两个入口对应的 Chunk 中；
- **资源冗余**。把所有资源全打入到一个包的策略会导致这个包体积快速增长。因为浏览器的特性，客户端必须等待所有的 js 文件全部加载完后才能够运行，但是用户当前可能只需要其中一部分代码；
- **缓存失效**。把所有资源打成一个包之后，哪怕一点东西的改动都会引起整个代码包的缓存失效。

上面的问题需要更加完善的分包策略来解决，例如：

- 被多个 Chunk 所使用的包分离成独立 Chunk，防止资源重复；
- `node_modules` 中的资源一般来说变动较少，可以抽成一个独立的包。业务逻辑的变更不会影响到这些第三方库资源包的缓存失效。

为此，Webpack 提供了 SplitChunksPlugin 插件来实现更加灵活的分包配置。

## SplitChunksPlugin 简介

`SplitChunksPlugin` 是 Webpack 4 之后内置实现的分包优化方案，不需要安装额外依赖，可以直接进行配置，具体的配置项是 `optimization.splitChunks`。

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      // ...
      chunks: 'all',
    },
  },
}
```

`splitChunks` 主要有两种类型的配置：

- `minChunks/minSize/maxInitialRequest` 等**默认分包条件**，满足这些条件的模块都会被执行分包；
- `cacheGroup` ：用于为特定资源声明**特定分包条件**，例如可以为 `node_modules` 包设定更宽松的分包条件。

## SplitChunksPlugin 的通用配置项

- **设置分包范围**，配置项`chunks`。
  - 默认情况下`SplitChunksPlugin`只对 Async Chunk 生效。
  - 可以通过 `chunks` 来调整分包范围，最常用的`all`可以对所有 chunk 生效。
- **根据 Module 使用频率进行分包**，配置项`minChunks`。
  - 这里的使用频率并不直接等同于被 `import` 的次数，而是被 Chunk 使用的次数。
- **限制分包数量**，配置项`maxInitialRequest`和`maxAsyncRequests`。
  - 如果包拆的非常细碎，那么会产生大量网络请求，反而降低性能。
  - 上述的两个配置项可以限制 Initial Chunk 和 Async Chunk 的最大并行请求数，来限制分包数量。
  - 所谓**请求数**指的是一个 Chunk 被加载时，所需加载的全部分包数。例如 ChunkA 分了三个分包，那么在加载 ChunkA 的时候要发 4 个请求。
- **限制分包体积**，配置项`minSize`/`maxSize`/`maxAsyncSize`/`maxInitialSize`/`enforceSizeThreshold`。
  - 这些配置项可以优化分包的产物，防止分包过小导致太碎，或者防止单个 Chunk 过大。
  - `minSize`：超过这个尺寸的 Chunk 才会进行分包；
  - `maxSize`/`maxAsyncSize`/`maxInitialSize`：超过这个尺寸的 Chunk 会进一步分包，后两个分别负责 Async Chunk 和 Initial Chunk
  - `enforceSizeThreshold`：超过这个尺寸的会强制分包。

结合上面的这一系列配置，SplitChunksPlugin 的大致工作流程如下：

```txt
minChunks是否命中=>maxInitialRequest是否命中=>maxSize那几个是否命中=>minxSize是否命中=>全部命中则分包

enforceSizeThreshold跳过判断强制分包
```

## 缓存组 cacheGroups

上述的那些配置都属于分包条件，决定了什么情况下要进行分包。`cacheGroups`配置项则可以对文件进行条件分组，对不同的文件组设置不同的规则，例如：

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          minChunks: 1,
          minSize: 0,
        },
      },
    },
  },
}
```

示例通过 `cacheGroups` 属性设置 `vendors` 缓存组，所有命中 `vendors.test` 规则的模块都会被归类 `vendors` 分组，优先应用该组下的 `minChunks`、`minSize` 等分包配置。

`cacheGroups` 支持上述 `minSice/minChunks/maxInitialRequest` 等条件配置，此外还支持一些与分组逻辑强相关的属性。

## 总结

Chunk 是 Webpack 模块打包的关键设计。Webpack 会首先将各模块按照引入方式打包成 Initial Chunk 和 Async Chunk，然后通过配置 `SplitChunksPlugin` 来进行进一步优化。

`SplitChunksPlugin` 的配置项比较复杂，不过主要来说可以分为两类：

- 打包规则，如`chunks`/`minChunks`等配置项，匹配这些策略的 Module 会被单独分包；
- 组别设置`cacheGroups`，可以对满足条件的文件组别赋予独立的打包规则。

实践中，一般采用的打包策略有两种：

- 将 `node_modules` 中的文件单独打包（一般称为 `vendor`）；
- 将变动频繁的模块进行单独打包（一般称为 `common`）
