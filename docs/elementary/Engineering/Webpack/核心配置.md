---
sidebar_position: 5
description: 'Webpack 的一些核心配置项'
---

# 核心配置项

Webpack 有几十上百个配置项。其中最核心的有：

- `entry`：声明项目入口文件，Webpack 会从这个文件开始递归找出所有文件依赖；
- `output`：声明构建结果的存放位置；
- `target`：配置产物的目标运行环境，支持 `web`/`node`/`electron`等，不同环境的最终产物会有差异；
- `mode`：编译模式短语，支持`development`/`production`等值，Webpack 会根据该属性推断默认配置；
- `optimization`：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能；
- `module`：用于声明模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理；
- `plugin`：Webpack 插件列表。

下面对这些核心配置项进行详解。

## entry 入口

webpack 的基本运行逻辑是从**入口文件**开始的，几乎所有项目都需要进行 `entry` 的配置。`entry`支持以下的配置方式：

- 字符串：指定入口文件路径
- 对象：可以在对象中进行复杂配置
- 函数：动态生成配置信息
- 数组：指明多个入口文件

例如:

```js
module.exports = {
  //...
  entry: {
    // 字符串形态
    home: './home.js',
    // 数组形态
    shared: ['react', 'react-dom', 'redux', 'react-redux'],
    // 对象形态
    personal: {
      import: './personal.js',
      filename: 'pages/personal.js',
      dependOn: 'shared',
      chunkLoading: 'jsonp',
      asyncChunks: true,
    },
    // 函数形态
    admin: function () {
      return './admin.js'
    },
  },
}
```

这其中，通过对象配置方式可以进行进一步的细节配置，其中比较重要的有：

- `import`:声明入口文件
- `dependOn`:声明该入口的前置 bundle
- `runtime`:设置该入口的 runtime Chunk，若此项不为空，则 Webpack 会将该入口的运行时代码抽离成单独的 Bundle

### dependOn 详解

`dependOn`用于声明前置 Bundle 依赖，其目的和作用是减少重复代码，优化构建产物质量。例如:

```js
module.exports = {
  // ...
  entry: {
    main: './src/index.js',
    foo: { import: './src/foo.js', dependOn: 'main' },
  },
}
```

这段配置文件中，`foo` 的 `dependOn` 属性指向了 `main`。他的意思是：**在加载`foo`之前一定会加载`main`**。因此可以将重复的模块代码、运行时代码等都放到 `main` 里面，减少重复代码。

`dependOn` 适用于那些有着明确入口依赖的场景。比如说现在有一个主框架 Bundle，其中包含 React，然后每个页面各自构建 Bundle，就可以将这些页面代码的 `dependOn` 设置为主框架，优化产物内容。

### runtime 详解

为了支持代码在各种环境下运行，Webpack 会在产物文件中注入一系列运行时代码，比如各种`__webpack_require__`之类的代码。在极端情况下，运行时代码量会特别大。因此，可以尝试使用 `runtime` 配置将运行时代码抽离成独立的 Bundle。例如：

```js
const path = require('path')

module.exports = {
  mode: 'development',
  devtool: false,
  entry: {
    main: { import: './src/index.js', runtime: 'common-runtime' },
    foo: { import: './src/foo.js', runtime: 'common-runtime' },
  },
  output: {
    clean: true,
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist'),
  },
}
```

这段配置中，`foo` 和 `main` 的 `runtime`都声明为`common-runtime`。此时 Webpack 会将这两个入口的运行时代码都抽取到`common-runtime`当中。

## output 输出方式

Webpack 的 `output` 配置项用于声明：如何输出构建结果、产物放在什么地方、文件名是什么等情况。常用的子配置项有:

- `output.path`:声明产物放在什么文件目录下
- `output.filename`:声明产物文件名规则
- `output.publicPath`:文件发布路径

## target 构建目标

虽然大部分情况下 Webpack 都用来进行 web 应用打包，但是 Webpack 也支持构建 Node、Electron 等应用形态，这一特性主要通过 `target` 配置来控制。

不同构建目标会根据平台特性打包出略有差异的结果。

## mode 编译模式短语

webpack 内置了一些构建优化策略，可以通过 `mode` 来切换默认优化规则。支持如下值:

- `production`：默认值，生产模式，使用该值 Webpack 会自动开启一系列优化措施：`Tree-shaking`/`Terser` 压缩代码/`SplitChunk` 提取公共代码等。常用语生产环境构建。
- `development`：开发模式，使用该值时 Webpack 会保留更语义化的 Module 与 Chunk 名称，更有助于调试，通常用于开发环境构建.
- `none`：关闭所有内置优化规则。

通常的，一般在开发模式使用 `mode = 'development'`，生产模式使用 `mode = 'production'` 即可。
