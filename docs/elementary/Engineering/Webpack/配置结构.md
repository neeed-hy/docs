---
sidebar_position: 4
description: 'Webpack 的配置结构分析'
---

# 配置结构

最常见的 Webpack 配置是这样的，他导出一个对象：

```js
module.exports = {
  entry: './src/index.js',
  // 其它配置...
}
```

实际上，Webpack 还支持数组、函数等方式来进行配置。主要区别在于：

- 单个配置对象：最常用的方式，适合大多数项目；
- 配置对象数组：每个数组项都是一个完整的配置对象，每个对象都会触发一次单独的构建，通常用于需要为同一份代码构建多种产物的场景，如 Library；
- 函数：Webpack 启动时会执行该函数获取配置，我们可以在函数中根据环境参数(如 NODE_ENV)动态调整配置对象。

## 数据类型配置

使用数组方式配置的样例如下：

```js
// webpack.config.js
module.exports = [
  {
    output: {
      filename: './dist-amd.js',
      libraryTarget: 'amd',
    },
    name: 'amd',
    entry: './app.js',
    mode: 'production',
  },
  {
    output: {
      filename: './dist-commonjs.js',
      libraryTarget: 'commonjs',
    },
    name: 'commonjs',
    entry: './app.js',
    mode: 'production',
  },
]
```

使用数组方式时，Webpack 会在启动后创建多个编译实例，并行执行构建工作，但需要注意，编译实例间基本上不作通讯，这意味着这种并行构建对运行性能并没有任何正向收益，

此外使用数组方式时，还可以借助 `webpack-merge` 工具简化配置逻辑。将公共配置抽取为 `baseConfig` 对象，之后配合 `webpack-merge` 创建不同目标数组项，例如：

```js
const { merge } = require('webpack-merge')

const baseConfig = {
  output: {
    path: './dist',
  },
  name: 'amd',
  entry: './app.js',
  mode: 'production',
}

module.exports = [
  merge(baseConfig, {
    output: {
      filename: '[name]-amd.js',
      libraryTarget: 'amd',
    },
  }),
  merge(baseConfig, {
    output: {
      filename: './[name]-commonjs.js',
      libraryTarget: 'commonjs',
    },
  }),
]
```

## 函数类型配置

可以为不同场景传入不同命令行参数，从而实现环境隔离效果。例子：

```js
module.exports = function (env, argv) {
  // ...
  return {
    entry: './src/index.js',
    // 其它配置...
  }
}
```

不过这种方式并不常用:

- 一是因为需要在配置函数内做许多逻辑判断，复杂场景下可能可读性会很低，维护成本高
- 二是强依赖于命令行参数，可能最终需要写出一串很长的运行命令，应用体验较差。

目前社区比较流行通过不同配置文件区分不同环境的运行配置，配合 `--config` 参数实现环境治理。

## 环境治理策略

同一个项目，在不同的环境下，可能需要不同的配置文件。例如：

- 开发环境需要热更新
- 测试环境需要 Sourcemap 来定义问题
- 生产环境需要压缩代码，减少包体积

目前，比较流行的治理策略是将不同环境配置分别维护在单独的配置文件中，例如这样：

```txt
└── config
  ├── webpack.common.js
  ├── webpack.development.js
  ├── webpack.testing.js
  └── webpack.production.js
```

之后再通过 `--config` 的方式来指定配置文件，例如:

```shell
npx webpack --config webpack.development.js
```

这种模式下通常会将部分通用配置放在基础文件中，如上例的 `webpack.common.js`，之后在其它文件中引入该模块并使用 `webpack-merge` 合并配置对象。一个典型的例子有：

首先是通用配置文件：

```js
// webpack.common.js
const path = require('path')
const HTMLWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: { main: './src/index.js' },
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: ['babel-loader'],
      },
    ],
  },
  plugins: [new HTMLWebpackPlugin()],
}
```

然后是对应环境配置文件：

```js
// webpack.development.js
const { merge } = require('webpack-merge')
const baseConfig = require('./webpack.common')

// 使用 webpack-merge 合并配置对象
module.exports = merge(baseConfig, {
  mode: 'development',
  devtool: 'source-map',
  devServer: { hot: true },
})
```

最后，指定配置文件进行构建：

```shell
npx webpack --config webpack.development.js
```
