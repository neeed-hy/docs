---
sidebar_position: 3
---

# 浏览器存储

[[toc]]

## 本地存储

### 概述

一共有四种方式可以实现本地存储。大体上的特点如下：

| 特性         | cookie                                                               | localStorage             | sessionStorage | indexDB                  |
| ------------ | -------------------------------------------------------------------- | ------------------------ | -------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间，不设置过期时间的话页面关闭就清理 | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K                                                                   | 5M                       | 5M             | 无限                     |
| 与服务端通信 | 每次都会携带在 header 中                                             |

从上表中可以看出，cookie 已经不建议用于存储。对于不怎么改变的数据尽量使用 localStorage，否则使用 sessionStorage。有大数据量存储需求用 indexDB。

### cookie

#### 基础

cookie 的原本用途是用来弥补 HTTP 在状态管理上的不足。HTTP 是一个无状态协议，发请求--返回响应，仅此而已。为了“让服务端知道客户端是谁”，设计了 cookie 技术。

cookie 的本质是**浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储**。

cookie 是**不可跨域**的。cookie 不能在不同的域名下使用。每个 cookie 都会绑定单一的域名。

#### cookie 的属性

可以打开 F12-Application-Cookies 进行查看。正如上面所述，cookie 实际上是一个键值对文件，他的属性是固定的。cookie 的属性有下面几种：

| 属性名          | 描述                                                                                                                                                                                                    |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name            | 代表 cookie 的名字。一个域名下绑定的 cookie，name 不能相同，否则后面设置的会覆盖掉前面设置的。                                                                                                          |
| value           | 代表 cookie 的值。值只能是字符串。由于 cookie 规定是名称/值是不允许包含分号，逗号，空格的，所以为了不给用户到来麻烦，考虑服务器的兼容性，任何存储 cookie 的数据都应该被编码。                           |
| domain          | 指的是 cookie 绑定的域名。该域名下的网站可以访问此 cookie。如果设置为`.google.com`，则所有以`google.com`结尾的域名都可以访问该 Cookie。注意一般来说第一个字符必须为`.`。                                |
| path            | Cookie 的使用路径。例如设置为`/sessionWeb/`，则只有 contextPath 为`/sessionWeb`的程序可以访问该 Cookie。如果设置为/，则本域名下 contextPath 都可以访问该 Cookie。注意最后一个字符必须为`/`。默认为`/`。 |
| Expires/Max-Age | 这个属性设置了 cookie 的**有效期**。                                                                                                                                                                    |
| HttpOnly        | 一个布尔值。当他设置为 true 时，就**没有办法使用 js 来获取这个 cookie 的值**。这样可以防止 cookie 被窃取。                                                                                              |
| secure          | 一个布尔值。HTTP 协议容易被劫持，导致不安全。当这个属性设置为 true 时，该 cookie 只会在 HTTPS 和 SSL 等安全协议下传输。                                                                                 |
| SameSite        | 是否是“同站 cookie”。可以设置为三个值：Strict、Lax 和 None。                                                                                                                                            |

#### cookie 的有效期

主要靠 `Expires/Max-Age` 这个属性来控制。

默认来说，这个属性下的值为 `session`，代表浏览器结束这个会话的时候，这个 cookie 也会被删除。这种 cookie 也叫做**会话 cookie**。

如果想让 cookie 存在一段时间，需要手动设定 Expires/Max-Age 属性的值。

Expires（特定日期） 是一个时间点。代表在指定的日期外 cookie 过期。

Max-Age（特定时间长度）是一个以秒为单位的数字。  
Max-Age 为正数时，代表 cookie 会在 Max-Age 秒后被删除;  
Max-Age 为负数时，代表 cookie 为临时性，不会被写到 cookie 文件中，浏览器关闭的话 cookie 消失;  
Max-Age 为 0，代表删除该 cookie。  
默认为-1。

#### cookie 的作用域

作用域靠 domain 和 path 两个属性来控制。在父级域设置的 cookie 在子级域可以拿到。

具体的控制方法用例子说明比较直观：

> domain 表示的是 cookie 所在的域，默认为请求的地址，如网址为 `www.study.com/study`，那么 domain 默认为 `www.study.com`。
>
> 而跨域访问，如域 A 为 `t1.study.com`，域 B 为 `t2.study.com`，那么在域 A 生产一个令域 A 和域 B 都能访问的 cookie 就要将该 cookie 的 domain 设置为`.study.com`；如果要在域 A 生产一个令域 A 不能访问而域 B 能访问的 cookie 就要将该 cookie 的 domain 设置为 `t2.study.com`。**注意：一般在域名前是需要加一个"."的**，如`domain=.study.com`。
>
> Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 。比如设置 Path=/docs，/docs/Web/ 下的资源会带 Cookie ，/test 则不会携带 Cookie 。

#### SameSite

##### 什么是 SameSite

SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。

要了解 SameSite 首先要明白跨域和跨站的概念。

- 跨域

  同源/跨域概念基于浏览器的同源策略。同源网站指的是协议、主机名、端口全部一致的网站。例如`https://www.taobao.com`，协议是 https，主机名是`www.taobao.com`，端口是 443。  
  同源/跨域的判定还是比较严格的。

- 跨站

  cookie 的同站/跨站概念和第一方/第三方概念是等价的。

  其判断也比跨域宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。

  其中，eTLD 表示有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中，例如，.com、.co.uk、.github.io 等。

  eTLD+1 则表示，有效顶级域名+二级域名，例如 `taobao.com` 等。

  举例说明：

  | URL                                       | 关系                                                      |
  | ----------------------------------------- | --------------------------------------------------------- |
  | `www.taobao.com`<br />`www.baidu.com`      | 跨站                                                      |
  | `www.a.taobao.com`<br />`www.b.taobao.com` | 同站                                                      |
  | `a.github.io`<br />`b.github.io`           | 跨站<br />（这两个 URL 的 eTLD 是`.github.io`而不是`.io`） |

Samesite 有三种值：**Strict 、LAX、none**。

##### Strict

这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。

比如说 `b.com` 设置了如下 Cookie：

```js
Set-Cookie: foo=1; Samesite=Strict
Set-Cookie: bar=2; Samesite=Lax
Set-Cookie: baz=3
```

我们在 `a.com` 下发起对 `b.com` 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。

举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。

##### Samesite=Lax

这种称为宽松模式，比 Strict 放宽了点限制：只能在 get 方法提交表单况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。

和上面一样， `b.com` 设置了如下 Cookie：

```js
Set-Cookie: foo=1; Samesite=Strict
Set-Cookie: bar=2; Samesite=Lax
Set-Cookie: baz=3
```

当用户从 `a.com` 点击链接进入 `b.com` 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。

但假如这个请求是从 `a.com` 发起的对 `b.com` 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。

##### Samesite=None

在 None 模式下，请求会自动携带上 Cookie。

Chrome80 之前,默认是 None 的，Chrome80 后默认是 Lax。

##### 例子

以上说法还是有点晦涩，下面给出一个对比图表，直观的进行对比：

| 请求类型  | 实例                             | chrome80 之前 | Strict | Lax         | None        |
| --------- | -------------------------------- | ------------- | ------ | ----------- | ----------- |
| 链接      | `<a herf="...">`                 | 发送 cookie   | 不发送 | 发送 cookie | 发送 cookie |
| 预加载    | `<link rel="prerender" herf="">` | 发送 cookie   | 不发送 | 发送 cookie | 发送 cookie |
| get 表单  | `<from method="GET" action="">`  | 发送 cookie   | 不发送 | 发送 cookie | 发送 cookie |
| post 表单 | `<from method="POST" action="">` | 发送 cookie   | 不发送 | 不发送      | 发送 cookie |
| iframe    | `<iframe src="...">`             | 发送 cookie   | 不发送 | 不发送      | 发送 cookie |
| ajax      | `$.get("...")`                   | 发送 cookie   | 不发送 | 不发送      | 发送 cookie |
| image     | `<img src="...">`                | 发送 cookie   | 不发送 | 不发送      | 发送 cookie |

### localStorage

#### localStorage 基础

- localStorage 和 cookie 一样，也有作用域限制。同一个域名下的页面可以读取到同一段 localStorage。页面间读取的权限符合浏览器的同源策略。
- localStorage 理论上来说是永久有效的，即不主动清空的话就不会消失。不过在移动设备上或者 WebView 中，localStorage 中的内容可能会因为各种原因（比如说退出 App、网络切换、内存不足等原因）被清空。

#### 基本使用方法

```js
let obj = { name: "sanyuan", age: 18 };
localStorage.setItem("name", "sanyuan");
localStorage.setItem("info", JSON.stringify(obj));
let name = localStorage.getItem("name");
let info = JSON.parse(localStorage.getItem("info"));
```

从代码中可以看到，localStorage 存储的都字符串。如果要进行对象的存储/读取，要使用`JSON.stringify()`和`JSON.parse()`方法。

利用 localStorage 的较大容量和持久特性，可以利用 localStorage 存储一些内容稳定的资源，比如官网的 logo，存储 Base64 格式的图片资源。

### sessionStorage

sessionStorage 和 localStorage 基本一致。主要的区别在于：

- sessionStorage 只是会话级别的存储。退出页面之后 sessionStorage 就会被清空。
- 哪怕是同源网站的不同页面，sessionStorage 也不会被共享。换言之，sessionStorage 是绑定在**窗口**上的。

应用场景

- 可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
- 可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用 sessionStorage 就再合适不过了。事实上微博就采取了这样的存储方式。

### IndexedDB

IndexedDB 是运行在浏览器中的一个非关系型数据库。他的容量没有上限。

- 作为非关系型数据库，IndexedDB 采用键值对进行存储。
- 虽然 IndexedDB 是运行在浏览器中的，但读取 IndexedDB 仍然属于 I/O 操作，属于异步操作。
- IndexedDB 的访问权限受浏览器同源策略限制。

### 总结

- cookie 不再适合进行数据存储;
- WebStorage 只存储字符串；默认不会参与和服务器的通信;
- IndexDB 是运行在浏览器中的非关系型数据库，可以存储/操作大规模数据。

## 缓存

### 缓存策略

浏览器中的缓存分为两种情况，一种是需要发送 HTTP 请求，一种不需要发送请求。

缓存策略依靠设置 HTTP Header（请求、响应都有）中的某些具体字段来控制。

#### 强缓存

首先是检查**强缓存**，这个阶段**不需要发送 HTTP 请求**。

根据 HTTP 协议版本的不同，具体的控制字段也不同。在 HTTP/1.0 和 HTTP/1.1 当中，这个字段是不一样的。在早期，也就是 HTTP/1.0 时期，使用的是 **Expires**，而 HTTP/1.1 使用的是 **Cache-Control**。

##### Expires

在 HTTP/1.0 年代使用 Expires 字段。

Expires 即过期时间，存在于服务端返回的**响应头**中。这个字段告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。

```js
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源在`2019年11月22号8点41分`过期，过期了就得向服务器重新发送请求。

Expires 最大的问题是**受限于本地时间**。如果修改了本地时间，或者本地时间和服务器时间不一致，那么会导致缓存设置无效。因此在 HTTP/1.1 年代被取代了。

##### Cache-Control

在 HTTP/1.1 年代使用 Cache-Control 字段。存在于**请求/响应头**中

Cache-Control 和 Expires 的思路一致，都是"在一段时间之后资源过期"。但是他并**没有采用设置具体时间点**的方式，而是采用**设置过期时长**的方式来控制，对应的字段是**max-age**。

```js
Cache-Control:max-age=3600
```

上面的代码表示在 3600 秒之后该资源过期。

Cache-Control 不止有 max-age 一个字段。他可以组合很多指令，形成综合的缓存控制方法。常用字段有：

Expires 能做的事情，Cache-Control 都能做；Expires 完成不了的事情，Cache-Control 也能做。

因此，Cache-Control 可以视作是 Expires 的**完全替代方案**。在当下的前端实践里，我们继续使用 Expires 的唯一目的就是**向下兼容**。

当 Expires 和 Cache-Control 同时存在时，会优先考虑 Cache-Control。

###### no-store 与 no-cache

**no-cache** 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。

**no-store** 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。

#### 协商缓存

当强缓存过期，浏览器就需要发起请求验证资源是否有更新。这就是**协商缓存**。

协商缓存同样靠 HTTP Header 中的字段来控制。分别是 **Last-Modified** 和 **ETag**。

##### Last-Modified

即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在**响应头**中加上这个字段。

浏览器接收到后，如果再次请求，会在**请求头**中携带 **If-Modified-Since** 字段。这个字段的值是服务器传来的最后修改时间。

服务器拿到请求头中的 **If-Modified-Since** 字段后，会和这个服务器中**该资源的最后修改时间**做对比：

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的 HTTP 请求一样。
- 否则返回 304，告诉浏览器直接使用缓存。

##### ETag

**Last-Modified** 有两个弊端：

- **Last-Modified** 过期时间只能精确到秒。如果在一秒内文件发生多次变化，服务器不会返回最新的文件;
- 如果缓存文件在服务器端被修改了，但是实际内容没有发生变化（例如先修改一次，第二次又改回来了），服务器端仍然会认为缓存过期，重新返回文件。

**ETag** 字段弥补了这个弊端。

服务器根据当前文件的内容，给文件生成唯一标识。文件里面的内容有改动，这个值就会变化，否则不变。在浏览器第一次给服务器发送请求时，服务器会在**响应头**中加上这个字段。

浏览器接受到这个字段后，会在下次请求时，在**请求头**中添加 **If-None-Match** 这个字段，将第一次接收到的 **ETag** 作为值，发送给服务器。

服务器接受到 **If-None-Match** 后，和服务器上该资源的 ETag 进行比对：

- 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求一样。
- 否则返回 304，告诉浏览器直接使用缓存。

Etag 的生成过程需要服务器**额外付出开销**，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——**Etag 并不能替代 Last-Modified**，它只能作为 Last-Modified 的**补充和强化存在**。  
Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。**当 Etag 和 Last-Modified 同时存在时，以 Etag 为准**。

### 缓存位置

当强缓存命中，或协商缓存命中服务器返回 304 时，会

浏览器中的缓存位置一共有四种：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

#### Service Worker

- Service Worker 是浏览器在**后台独立于网页运行的**、用 JavaScript 编写的脚本。
- Service Worker 是 PWA 的核心技术。
- Service Worker 可以拦截并处理 HTTP 请求。基于这个原因，Service Worker 必须使用 HTTPS 协议来保证安全。

Service Worker 使用的大体流程：

- 我们需要手动编写 service-worker.js 文件（这个文件就是 Service Worker 文件）。
- 我们需要在网页中下载并注册 service-worker.js 文件。
- Service Worker 具有超能力，可以拦截并处理 HTTP 请求。

#### Memory Cache 和 Disk Cache

- **Memory Cache**：存储在内存中的缓存。**读取效率高，但是存活时间短**，会随着进程的释放而释放。关闭页面后缓存就不存在了。

- **Disk Cache**：存储在硬盘中的缓存。读取速度稍慢，但**容量、时效性**比 Memory Cache 更好。

哪些文件会放到内存、哪些文件会放到磁盘，这个过程据说比较**玄学**。可能的主要策略：

- 比较大的 JS、CSS 文件会优先使用磁盘缓存，反之亦然;
- 系统内存使用率高的时候，优先存储进磁盘。

#### Push Cache

Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。

由于目前国内 HTTP/2 不够普及，所以 Push Cache 的应用偏少。具体可以参考[HTTP/2 push is tougher than I thought]这篇文章。下面是几个结论：

- 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
- 可以推送 no-cache 和 no-store 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 你可以给其他域名推送资源

## 参考出处

1. [yck 小册](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5c06769251882516cd70cfe9)
2. [神三元-浏览器灵魂之问](https://juejin.im/post/5df5bcea6fb9a016091def69#heading-0)
3. [laihuamin-把 cookie 聊清楚](https://juejin.im/post/59d1f59bf265da06700b0934)
4. [程序员 cxuan-看完这篇 Session、Cookie、Token，和面试官扯皮就没问题了](https://juejin.im/post/5e893002f265da48094d8cd3)
5. [545 龙哥哥-cookie 的 domain 属性](https://blog.csdn.net/longgege001/article/details/81274088)
6. [Amos_Shen-localStorage 的跨域存储方案](https://www.jianshu.com/p/e86d92aeae69)
7. [array_huang-localstorage 必知必会](https://juejin.im/post/5a9fcc5e51882555602074e3)
8. [MDN-使用 IndexedDB](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB)
9. [玉鸯-新一代的前端存储方案--indexedDB](https://juejin.im/post/5b09a641f265da0dcd0b674f)
10. [lucefer-面试精选之 http 缓存](https://juejin.im/post/5b3c87386fb9a04f9a5cb037)
11. [HTTP/2 push is tougher than I thought]
12. [快狗打车前端团队-Service Worker 从入门到出门](https://juejin.im/post/5d26aec1f265da1ba56b47ea)
13. [冴羽-Cookie 的 SameSite 属性](https://juejin.im/post/5e718ecc6fb9a07cda098c2d)
14. [ConardLi-当浏览器全面禁用三方 Cookie](https://juejin.im/post/5e97124df265da47b27d97ff)

[http/2 push is tougher than i thought]: https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/

通常 cookie 的域和浏览器地址的域匹配，这被称为第一方 cookie。那么第三方 cookie 就是 cookie 的域和地址栏中的域不匹配，这种 cookie 通常被用在第三方广告网站。为了跟踪用户的浏览记录，并且根据收集的用户的浏览习惯，给用户推送相关的广告。
