---
sidebar_position: 3
description: '同源策略、跨域现象以及跨域的解决方案'
---

# 跨域

## 浏览器同源策略

同源策略是一种约定，他是浏览器最核心也是最基本的安全功能。同源策略的同源指的是两个 URL 的**协议、域名、端口**一致。即使两个域名指向的 ip 地址一致，也不算同源。

下面这个表是一些例子：

| URL                                                              | 说明                           | 是否允许通信                            |
| ---------------------------------------------------------------- | ------------------------------ | --------------------------------------- |
| `http://www.a.com/a.js` <br />`http://www.a.com/b.js`            | 同一域名下                     | 允许                                    |
| `http://www.a.com/lab/a.js` <br />`http://www.a.com/script/b.js` | 同一域名下不同文件夹           | 允许                                    |
| `http://www.a.com:8000/a.js` <br />`http://www.a.com/b.js`       | 同一域名，不同端口             | 不允许                                  |
| `http://www.a.com/a.js` <br />`https://www.a.com/b.js`           | 同一域名，不同协议             | 不允许                                  |
| `http://www.a.com/a.js` <br />`http://70.32.92.74/b.js`          | 域名和域名对应 ip              | 不允许                                  |
| `http://www.a.com/a.js` <br />`http://script.a.com/b.js`         | 主域相同，子域不同             | 不允许                                  |
| `http://www.a.com/a.js`<br />`http://file.a.com/b.js`            | 同一域名，不同二级域名（同上） | 不允许（cookie 这种情况下也不允许访问） |
| `http://www.cnblogs.com/a.js` <br />`http://www.a.com/b.js`      | 不同域名                       | 不允许                                  |

同源策略主要限制的内容有：

- cookie、WebStorage 等存储性内容
- Ajax 请求
- DOM 节点，例如 iframe 内的 DOM ，在外层访问不到。

但是有三个标签是允许跨域的：

- `<script src="...">`
- `<img src="...">`
- `<link herf="...">`

需要注意的一个概念：**请求跨域了，那么请求到底发出去了没有**？

**实际上请求已经发出去了，服务器也进行了返回，只不过是浏览器将返回拦截了**。所有的 ajax 都会被拦截，但是提交表单是可以跨域的。这是为什么？

同源策略的本质是阻止用户**读取**另一个域名下的内容。Ajax 请求可以获取响应，因此浏览器认为不安全；提交表单并不会获取新的内容，因此浏览器允许其发起跨域请求。

基于以上，浏览器的同源策略也并不能完全阻止 CSRF 攻击。毕竟请求已经发出去了。

## 跨域解决方案

传说中有 9-10 中跨域解决方案。[这篇](https://juejin.im/post/5c23993de51d457b8c1f4ee1)文章讲的比较详细。不过目前比较主流的有三种解决方案：

### 最经典的解决方案 jsonp

jsonp 是利用`<script>`标签不受同源策略限制的特性进行跨域操作。

jsonp 优点：

- 实现简单
- 兼容性好

jsonp 缺点：

- 只支持 get（因为`<script>`标签只支持 get）
- 容易受到 XSS 攻击
- 需要服务端做一定程度的改造

### 最流行的解决方案 CORS

CORS 需要浏览器和后端同时支持。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键在于后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 **Access-Control-Allow-Origin** 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符`*`则表示所有网站都可以访问资源。

不过需要注意的是，如果**前端请求需要携带 cookie，那么后端 Access-Control-Allow-Origin 不能设置为全部，也就是`*`**,必须进行具体的设置。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

- 简单请求

  同时满足以下两个条件的请求就是简单请求：

  条件 1：使用下列方法之一：

  - GET
  - HEAD
  - POST

  条件 2：Content-Type 的值仅限于下列三者之一：

  - text/plain
  - multipart/form-data
  - application/x-www-form-urlencoded

  请求中的任意 `XMLHttpRequestUpload` 对象均没有注册任何事件监听器； `XMLHttpRequestUpload` 对象可以使用 `XMLHttpRequest.upload` 属性访问。

  对于简单请求，浏览器进行了以下处理：

  - 在请求头中，添加一个 **Origin** 字段，来说明请求来自于**哪个源**。
  - 服务器拿到请求之后，在回应时对应的添加 **Access-Control-Allow-Origin**字段，如果 **Origin** 不在这个字段的范围中，那么**浏览器就会将响应拦截**。
  - **Access-Control-Allow-Origin** 字段是服务器用来决定浏览器是否拦截这个响应，是实现 CORS 必需的字段。

  还有一些其他的功能性字段也在 CORS 中起作用（这些字段都是在服务端设置）：

  - **Access-Control-Allow-Credentials**：一个布尔值，表示是否允许发送 Cookie。默认为 false，如果想要拿到 Cookie 需要将这个字段设置为 true，并且前端在发送请求时也要设置 **withCredentials**
  - **Access-Control-Expose-Headers**：让前端可以拿到更多的响应头字段。默认情况下，只可以拿到**Cache-Control、Content-Language、Content-Type、Expires、Last-Modified 和 Pragma**这些字段的值。通过设置 **Access-Control-Expose-Headers**字段，可以拿到更多的字段值。

    用法和例子：

    ```http
    // 用法
    Access-Control-Expose-Headers: <header-name>, <header-name>, ...
    // 例子
    Access-Control-Expose-Headers: Content-Length
    ```

    这样就允许前端拿到 Content-Length 的值。

- 复杂请求

  不符合以上条件的请求就肯定是复杂请求了。  
   复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为**"预检"请求**,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

  举例说明：

  下面要发送一个 PUT 请求：

  ```http
  var url = 'http://xxx.com';
  var xhr = new XMLHttpRequest();
  xhr.open('PUT', url, true);
  xhr.setRequestHeader('X-Custom-Header', 'xxx');
  xhr.send();
  ```

  在执行这个请求时，首先会发送**预检请求**：

  ```http
  OPTIONS / HTTP/1.1
  Origin: 当前地址
  Host: xxx.com
  Access-Control-Request-Method: PUT
  Access-Control-Request-Headers: X-Custom-Header
  ```

  预检请求的方法是 OPTION，同时会加上 Origin 源地址和 Host 目标地址。同时也会加上两个关键的字段:

  - **Access-Control-Request-Method**, 列出 CORS 请求用到哪个 HTTP 方法
  - **Access-Control-Request-Headers**，指定 CORS 请求将要加上什么请求头

  预检请求的响应也分为两个部分：其一是对**预检请求**的响应，其二是对 **CORS 请求**的响应。例子：

  ```http
  HTTP/1.1 200 OK
  Access-Control-Allow-Origin: *
  Access-Control-Allow-Methods: GET, POST, PUT
  Access-Control-Allow-Headers: X-Custom-Header
  Access-Control-Allow-Credentials: true
  Access-Control-Max-Age: 1728000
  Content-Type: text/html; charset=utf-8
  Content-Encoding: gzip
  Content-Length: 0
  ```

  关键字段说明：

  - **Access-Control-Allow-Methods**: 表示允许的请求方法列表。
  - **Access-Control-Allow-Headers**: 表示允许发送的请求头字段
  - **Access-Control-Max-Age**: 预检请求的有效期，在此期间，不用发出另外一条预检请求。
  - **Access-Control-Allow-Origin**: 表示可以允许请求的源，可以填具体的源名，也可以填\*表示允许任意源请求。
  - **Access-Control-Allow-Credentials**: 简单请求中已经介绍。

  上面的字段中，前三个是对预检请求的响应，后两个和简单请求一样，是对 CORS 的响应。

  在预检请求的响应返回后，如果真正要发送的响应不满足响应头的条件，触发 XMLHttpRequest 的 onerror 方法，真正的 CORS 请求就发不出去了。

  如果满足，那么就可以发送 CORS 请求了。到这一步就变得简单了，和**简单请求**一样，浏览器自动加上 **Origin** 字段，服务端响应头返回 **Access-Control-Allow-Origin**.

### 最方便的解决方案 nginx

nginx 是一个功能强大的反向代理 Web 服务器，具有轻量化、启动快、并发高等优点。

正向代理指的是**帮助客户端访问本来访问不到的服务器**，将结果返回给客户端；  
反向代理则是拿到客户端的请求，将请求转发给其他的服务器。也就是说，**反向代理帮助其他的服务器拿到请求**，然后选择一个合适的服务器，将请求转交给它。  
简而言之，正向代理帮客户端做事情，反向代理帮服务器做事情。

使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

使用 nginx 来解决跨域问题是新项目的首选方案。

在下载并安装 nginx 之后，需要修改配置文件 nginx.conf。常见的配置文件如下：

```nginx
// proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}

```

## 参考出处

1. [yck 小册](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc71fbf265da6128599324)
2. [神三元-HTTP 灵魂之问](https://juejin.im/POST/5e76bd516fb9a07cce750746)
3. [浪里行舟-九种跨域方式实现原理（完整版）](https://juejin.im/post/5c23993de51d457b8c1f4ee1)
4. [寻找海蓝 96-11 道浏览器原理面试题](https://juejin.im/post/5d89798d6fb9a06b102769b1#heading-20)
