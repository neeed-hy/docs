---
sidebar_position: 1
description: '浏览器内的进程、线程以及它们之间的关系'
---

# 进程与线程

## 基础概念

> 进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）;
>
> 线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。

用比喻的说明方式：

> 进程是工厂。每个工厂有他的独立资源。工厂之间相互独立。
>
> 线程是工厂中的工人，多个工人协作完成任务。工厂内可能有一个或多个工人，工人之间共享工作空间。

完善一下概念：

> 工厂资源 ---> 内存
>
> 工厂之间独立 ---> 进程间独立
>
> 厂内有一个或多个工人 ---> 一个进程由一个或多个线程组成
>
> 多个工人协作完成任务 ---> 多线程在进程中协作完成任务
>
> 工人之间共享空间 ---> 同一进程下的线程共享内存空间

## 浏览器的多进程

浏览器是一个多进程的软件。它包含的**主要**进程有：

- Browser 进程。

  Browser 进程是浏览器的主进程。只有一个。作用有：

  - 负责浏览器界面显示与交互。如前进后退。
  - 负责各个页面的管理，创建和销毁其他进程。
  - 绘制渲染进程中生成的位图。

- 网络进程

  主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

- 第三方插件进程

  每种类型的插件对应一个进程。

- GPU 进程

  最多一个。用于 3D 绘制等场景。

- Renderer 进程

  Renderer 进程是浏览器的渲染进程。也称为浏览器内核。  
  默认每个 Tab 页面一个进程，互相之间不影响。  
  主要执行任务有页面渲染、脚本执行、事件处理等。  
  Renderer 进程内部是多线程的。

基本上说，**浏览器中每打开了一个网页就相当于起了一个新的进程**。

在一些特殊情况下浏览器会将多个进程合并，比如开了多个空白页，这些空白页就会被合并成了一个进程。

浏览器这种多进程机制的优点在于：

- 单个页面崩溃不会影响到其他页面
- 第三方插件崩溃不会影响浏览器
- 提升算力、提升稳定性

## Renderer 进程（渲染进程）

对于前端来说，最重要的是浏览器中的渲染进程。页面的渲染、脚本的执行等重要工作全部在渲染进程内执行。

渲染进程是多线程的。它的重要线程有：

- GUI 渲染线程

  - 负责渲染浏览器界面。  
    解析 HTML、CSS，构建 DOM 树、CSSOM 树、Render Tree 渲染树，进行布局、绘制（指绘制到**内存**中，绘制到显示器上是 Browser 进程的工作）。
  - 当界面需要进行重绘 Repaint 或回流 Reflow 时，该线程就会执行。
  - **GUI 渲染线程和 JS 引擎线程是互斥的**！  
    当 JS 引擎执行时，GUI 渲染线程会被挂起，直到**JS 引擎结束执行，变为空闲**时才会继续。

- JS 引擎线程

  - 也称 JS 内核。负责处理执行 Javascript 脚本程序。最著名的 JS 引擎是 V8 引擎。
  - JS 引擎一直等待着任务队列中任务的到来，然后加以处理。**一个 Tab 页**（也就是一个 Renderer 渲染进程）**中只有一个 JS 引擎线程**在运行 JS 程序。
  - **GUI 渲染线程和 JS 引擎线程是互斥的**！  
    如果 JS 引擎执行时间过长，会造成页面渲染的阻塞。

- 事件触发线程

  - 归属于浏览器而不是 JS 引擎。用来控制事件循环。
  - 当 JS 引擎执行代码块如`setTimeout()`（或浏览器内核的其他线程，如 ajax 请求）时，会将对应任务添加到事件线程中。
  - 当对应的事件符合触发条件被触发时，该线程会把时间添加到待处理队列的队尾，等待 JS 引擎的处理。
  - 由于 JS 是单线程的，待处理队列中的时间都要排队等待 JS 引擎处理。

- 定时触发器线程

  - 传说中`setTimeout()`、`setInterval()`所在的线程。浏览器的这种定时计数器并不是 JS 引擎计数的，而是单独开了一个线程。
  - 计时完毕后，将任务添加到事件队列中，等待 JS 引擎执行。
  - > W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

- 异步 HTTP 请求线程

  - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求

  - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

## Renderer 进程中线程之间的一些关系

### GUI 渲染线程和 JS 引擎线程互斥

因为 JS 可以操作 DOM，所以如果 JS 线程和 GUI 线程同时运行，那么渲染线程前后获得的元素数据就可能不一致了。

为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程和 JS 引擎线程互斥。

### JS 阻塞页面加载

因为上面的互斥关系，JS 如果执行过长就会阻塞页面渲染。

因此要避免 JS 执行的时间过长，不要在 JS 中进行巨量的计算。

#### WebWorker，JS 的伪“多线程”

HTML5 中新增加的特性。

- 创建 Worker 时，JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作 DOM）

- JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程，只待计算出结果后，将结果通信给主线程即可。

而且注意下，JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。

### WebWorker 与 SharedWorker

既然都到了这里，就再提一下 SharedWorker（避免后续将这两个概念搞混）

- WebWorker 只属于某个页面，不会和其他页面的 Render 进程（浏览器内核进程）共享

  - 所以 Chrome 在 Render 进程中（每一个 Tab 页就是一个 render 进程）创建一个新的线程来运行 Worker 中的 JavaScript 程序。

- SharedWorker 是浏览器所有页面共享的，不能采用与 Worker 同样的方式实现，因为它不隶属于某个 Render 进程，可以为多个 Render 进程共享使用

  - 所以 Chrome 浏览器为 SharedWorker 单独创建一个进程来运行 JavaScript 程序，在浏览器中每个相同的 JavaScript 只存在一个 SharedWorker 进程，不管它被创建多少次。

WebWorker 与 SharedWorker 本质上就是进程和线程的区别。SharedWorker 由独立的进程管理，WebWorker 只是属于 render 进程下的一个线程

## Browser 进程和 Renderer 进程间的通信

- Browser 进程收到用户请求，首先获取页面内容（如下载资源），然后将该任务通过 RendererHost 接口传递给 Renderer 进程。
- Renderer 进程的 Renderer 接口收到消息，简单解释后交给渲染线程开始渲染：
  - 渲染线程接收请求，加载网页并渲染网页。期间可能需要 Browser 进程帮助下载资源、GPU 进程帮助渲染
  - JS 线程负责执行脚本。在执行的过程中可能会操作 DOM，因此和 GUI 渲染线程互斥。
  - 最后 Renderer 进程将渲染结果传输给 Browser 进程。
- Browser 进程接收渲染结果并绘制。

## 参考出处

1. [yck 小册](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc71fbf265da6128599324)
2. [神三元-浏览器灵魂之问](https://juejin.im/post/5df5bcea6fb9a016091def69#heading-0)
3. [阮一峰-进程与线程的一个简单解释](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
4. [dailc-从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理](https://juejin.im/post/5a6547d0f265da3e283a1df7)
5. [从 chrome 浏览器说说进行与线程](https://segmentfault.com/a/1190000020526789?_ea=20309599)
