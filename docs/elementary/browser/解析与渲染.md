---
sidebar_position: 4
---

# 浏览器解析与渲染

[[toc]]

## 前言

不同的浏览器内核有不同的渲染引擎，其渲染方法和渲染原理也不尽相同。常见的浏览器中，Chrome 和 Safari 都是 Webkit 引擎，Firefox 是 Gecko 引擎。不同引擎之间大同小异。

浏览器大体的解析与渲染流程如下：

解析：

- 构建 DOM 树
- 构建 CSSOM 树
- 根据 DOM 树和 CSSOM 树生成渲染树 Render tree

  > 据说 Render tree 的功能在 16 年之后的 Chrome 中被完全集成到了下一步构建的布局树中

- 构建布局树 Layout Tree

渲染：

- 建立图层树 Layer Tree
- 生成绘制列表
- 生成图块并栅格化
- 显示器显示内容

## 解析

### 解析流程

- 解析 HTML 文档，构建 DOM 树：

  - 打开网页，浏览器在拿到 HTML 文档时，首先会进行 HTML 文档解析，将字符串**标记化**。
  - 然后利用特定的**建树算法**，生成一个个 DOM 对象，再将 DOM 对象加入到 Dom 树中。
  - DOM 树的本质是**一个以 document 为根节点的多叉树**。
  - 在解析 HTML 文档时，当遇到外链 CSS，会对外链 CSS 进行下载。此时 HTML 的解析过程仍继续进行。

- 解析 CSS 文本，构建 CSSOM 树：

  - CSS 下载完成后，会首先进行**格式化**，解析 CSS 文件，生成**样式表 styleSheets**。
  - 有一些 CSS 的值并不能被浏览器所理解，因此在解析 CSS 的过程中，会进行样式属性的**标准化**。例如 `em->px`,`red->#ff0000`,`bold->700` 等等。
  - 在**格式化**、**标准化**之后，便可以计算节点的样式信息，生成 CSS 规则树 CSSOM 了。具体的计算规则是**继承**和**层叠**。

    - 每个子节点会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫 **UserAgent 样式**。这就是**继承规则**。
    - CSS 最大的特点在于他的**层叠性**，也就是说最终样式取决于各个属性共同作用的结果。

- **HTML 的解析和 CSS 的解析是相互独立的，不会造成冲突**。因此通常将 CSS 放在 head 中，这样可以让浏览器尽早的解析 CSS。

- 在 DOM 树以及 CSS 规则树生成完毕后，根据两者生成 render tree，即渲染树。

- 在渲染树生成完毕后，接下来要通过浏览器的布局系统确定元素的位置，即生成一个**布局树**。生成布局树的大致流程为：

  - 遍历渲染树的每一个节点，添加到布局树中；
  - 对于每一个布局树节点，计算其确切大小和位置，也就是几何坐标。
  - > 据说 Render tree 的功能在 16 年之后的 Chrome 中被完全集成到了下一步构建的布局树中

- 布局树只包含可见元素。对于`display: none`的元素，不会放入其中。

- 在渲染树生成完毕后，浏览器渲染引擎根据渲染树进行 layout(几何布局)或称 repaint(回流)。

### 解析中的 Javascript

由于 js 可能直接操作 DOM 树和 CSS 规则树，因此浏览器在解析 js 的过程中会停止对 HTML 以及 CSS 的解析。当遇到外链 js，会暂停解析过程，等待文件下载完毕后再继续执行。  
基于以上原因，才要将 `<script>` 标签放在最后，为的就是提升渲染的速度。

有一些方案可以对外链 js 的渲染进行特殊处理：  
`<script>`标签加上`defer`属性，表示该 js 文件会首先进行下载，在 HTML 解析完成后再进行解析。  
`<script>`标签加上`async`属性，表示该 js 文件不阻断渲染，一边下载文件一边进行渲染，下载完成后再执行。因此，使用`async`后不能像其他的 js 文件一样保证执行顺序。

![JS执行](http://segmentfault.com/img/bVcQV0)

## 渲染

### 图层树

在一些复杂的场景下，例如 3D 动画、元素含有层叠上下文(如`z-index`嵌套)时如何显示和隐藏，仅使用布局树无法绘制。因此浏览器在构建完布局树之后，还会对特定的节点进行分层，构建**图层树 Layer Tree**。

一般情况下，节点的图层会默认属于父节点的图层（这些图层也称为合成层）。一些情况下，节点的图层会进行提升，成为单独的合成层。

合成层有一个好处，就是如果一个层需要进行重绘 repaint 时，只需要重绘该图层，不会影响到其他的层。

图层提升的渠道有两种：显式合成、隐式合成。

#### 显式合成

- 拥有层叠上下文的节点。

  层叠上下文基本上是由一些的定的 CSS 属性所创建的。一般有以下情况：

  - HTML 根元素本身具有根级层叠上下文
  - 普通元素设置 `position` 不为 `static` 并且设置了 `z-index` 属性，会产生层叠上下文。
  - 元素的 `opacity` 值不是 1
  - 元素的 `transform` 值不是 `none`
  - 元素的 `filter` 值不是 `none`
  - 元素的 `isolation` 值是 `isolate`
  - `will-change` 指定的属性值为上面任意一个。(`will-change` 的作用后面会详细介绍)

#### 隐式合成

简单来说就是**层叠等级低的节点**被提升为单独的图层之后，所有**层叠等级比它高的节点**都会成为一个单独的图层。

隐式合成隐含着巨大的风险。当一个 `z-index` 比较低的元素被提升为单独图层之后，层叠在他上面的元素统统都会被提升为单独的图层，可能一次会增加几十上百个，这会大大增加内存的压力。这个现象叫做**层爆炸**。

### 生成绘制列表 

在图层树生成完毕后，渲染引擎将图层的绘制拆分成一个个绘制指令，比如先画背景、再画边框……，然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。

页面的绘制列表可以在 Chrome DevTools 中的 more tools 下的 Layers 看到。

### 生成图块和生成位图

这一步中才正式开始进行绘制。在浏览器中，绘制操作是由专门的线程来完成的，这个线程叫做**合成线程**。

当绘制列表准备好了以后，渲染进程的主线程会给合成线程发送 commit 消息，把绘制列表提交给合成线程。合成线程随即开始工作。

由于显示器的视口大小有限，当页面很大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事是将图层**分块**。分块的大小不会很大，一般是 `256*256` 或 `512*512`这个级别。这样可以加速页面的首屏展示。

因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。

> 针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。

实际生成位图的操作是由栅格化来进行的。渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块转换为位图数据**。合成线程会将视口附近的图块交给栅格化线程池生成位图。

栅格化完成后，合成线程发送绘图命令给浏览器进程。浏览器将页面内容绘制到内存，即生成页面，随后将该段内存发送给显卡，显卡绘制到显示器上，完成整个渲染过程。

## Repaint(重绘)与 Reflow(回流、重排)

首先来回顾一下渲染流水线的流程。

![渲染流水线](https://user-gold-cdn.xitu.io/2019/12/15/16f080ba7fa706eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 回流

#### 回流触发条件

简单来说，当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生**回流**的过程、

一般来说，以下的操作会触发回流：

- DOM 元素的几何属性变化。例如 width、height 等。详细请见下表。
  - 这个行为是最昂贵的，所有和他相关的节点的几何属性都需要进行重新计算，牵一发而动全身。
- DOM 节点增减或移动
  - 这个行为是一般昂贵的，DOM 一般会添加到 DOM 树中的某个位置，位置在他上面的 DOM 不会受影响。
- 调用`window.getComputedStyle()`方法。此方法的作用是获取当前元素所有最终使用的 CSS 属性值，返回的是一个 CSS 样式声明对象。
- 读写 offset 族、scroll 族和 client 族属性的时候，浏览器为了获取这些值，需要进行回流操作。
- 最后这两个**取值**的行为都是通过**即时计算**来得到。因此会触发回流。

![什么是这三个家族](https://upload-images.jianshu.io/upload_images/3131637-9145ecafff816360.png?imageMogr2/auto-orient/strip|imageView2/2/w/480/format/webp)

常见的引起回流的属性和方法：

| 常见引起回流属性和方法  |                          |                    |            |
| ----------------------- | ------------------------ | ------------------ | ---------- |
| width                   | height                   | margin             | padding    |
| display                 | border                   | position           | overflow   |
| clientWidth             | clientHeight             | clientTop          | clientLeft |
| offsetWidth             | offsetHeight             | offsetTop          | offsetLeft |
| scrollWidth             | scrollHeight             | scrollTop          | scrollLeft |
| scrollIntoView()        | scrollTo()               | getComputedStyle() |
| getBoundingClientRect() | scrollIntoViewIfNeeded() |

#### 回流过程

依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程（包括主线程之外的任务）全部走一遍。

![回流过程](https://user-gold-cdn.xitu.io/2019/12/15/16f0809e65b3d2fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

相当于将解析和合成的过程重新有走了一遍，开销是非常大的。

### 重绘

#### 重绘触发条件

当 DOM 的修改只导致了样式的变化，并没有影响几何属性的时候，会导致重绘。例如 color 变化就只会触发重绘。常见的引起重绘的属性包括：

| 常见引起重绘属性和方法 |                  |                     |                   |
| ---------------------- | ---------------- | ------------------- | ----------------- |
| color                  | border-style     | visibility          | background        |
| text-decoration        | background-image | background-position | background-repeat |
| outline-color          | outline          | outline-style       | border-radius     |
| outline-width          | box-shadow       | background-size     |

#### 重绘过程

由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程如下：

![重绘过程](https://user-gold-cdn.xitu.io/2019/12/15/16f080a26aa222d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

跳过了生成布局树和建图层树的阶段，**直接生成绘制列表**，然后进行分块、生成位图等操作。所需要的成本比回流小很多。

### 合成

还有一种情况，是直接合成。比如利用 CSS3 的 transform、opacity、filter 这些属性就可以实现合成的效果，也就是传说中的**GPU 加速**。

#### GPU 加速的原因

在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程来处理。交给它处理有两大好处:

- 能够充分发挥 GPU 的优势。合成线程生成位图的过程中会调用线程池，并在其中使用 GPU 进行加速生成，而 GPU 是擅长处理位图数据的。

- 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。

从上面的回流、重绘过程也可以看到，重绘不一定导致回流，但回流一定触发重绘。

#### 实践意义

- 避免频繁使用 style，而是采用修改 class 的方式。
- 使用 createDocumentFragment 进行批量的 DOM 操作。
- 对于 resize、scroll 等进行防抖/节流处理。
- 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于 tranform, 任何可以实现合成效果的 CSS 属性都能用 will-change 来声明。一个实际的例子：[一行`will-change: tranform`拯救一个项目](https://juejin.im/post/5da52531518825094e373372)。

## 减少 repaint 和 reflow

- CSS

  - 避免使用 table 布局
  - 尽可能在 DOM 树的最末端改变 class
  - 避免设置多层内联样式
  - 将动画尽量使用在绝对定位或固定定位的元素上；

- JavaScript
  - 避免直接操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。
  - 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。

## 参考出处

1. [yck 小册](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d)
2. [神三元-浏览器灵魂之问](https://juejin.im/post/5df5bcea6fb9a016091def69#heading-0)
3. [腰花-浏览器的回流与重绘 (Reflow & Repaint)](https://juejin.im/post/5a9923e9518825558251c96a)
4. [null 仔-从 8 道面试题看浏览器渲染过程与性能优化](https://juejin.im/post/5e143104e51d45414a4715f7)
5. [SylvanasSun-浏览器渲染过程与性能优化](https://juejin.im/post/59d489156fb9a00a571d6509)
6. [bs123-前端性能优化：细说浏览器渲染的重排与重绘](https://juejin.im/post/5b543e26e51d4518f54404e4)
7. [腾讯课堂 NEXT 学院-网站性能优化实战——从 12.67s 到 1.06s 的故事](https://juejin.im/post/5b0b7d74518825158e173a0c)
8. [CoyPan-从浏览器渲染原理，说一说如何实现高效的动画](https://juejin.im/post/5d2491ba6fb9a07ecf724b69)
9. [长安曹公子-彻底搞懂 CSS 层叠上下文、层叠等级、层叠顺序、z-index](https://juejin.im/post/5b876f86518825431079ddd6)
10. [淘系前端团队-无线性能优化：Composite](https://fed.taobao.org/blog/taofed/do71ct/performance-composite/?spm=taofed.blogs.header.7.415a5ac8oDMbbi)
11. [WecTeam-浏览器层合成与页面渲染优化](https://juejin.im/post/5da52531518825094e373372)
12. [winty-Chrome 页面呈现原理与性能优化](https://juejin.im/post/5e572a34518825490f722b9e)
